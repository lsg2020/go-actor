package main

import (
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

// protoc -I . --go_out=. --gactor_out=. *.proto

var (
	contextPackage = protogen.GoImportPath("context")
)

var (
	protoPackage  = protogen.GoImportPath("github.com/golang/protobuf/proto")
	gactorPackage = protogen.GoImportPath("github.com/lsg2020/go-actor")
	zapPackage    = protogen.GoImportPath("go.uber.org/zap")
)

func GenerateFile(gen *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	isGenerated := false
	for _, srv := range file.Services {
		for _, method := range srv.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				continue
			}
			isGenerated = true
		}
	}

	if !isGenerated {
		return nil, nil
	}

	filename := file.GeneratedFilenamePrefix + ".goactor.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-goactor. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)

	for _, srv := range file.Services {
		if err := genService(g, srv); err != nil {
			return nil, err
		}
	}

	return g, nil
}

func genService(g *protogen.GeneratedFile, srv *protogen.Service) error {
	genServiceInterface(g, srv)
	genConstructor(g, srv)
	genServer(g, srv)
	genClient(g, srv)

	return nil
}

const (
	MethodSend    = "SEND"
	MethodCall    = "CALL"
	MethodRawCall = "RAW_CALL"
)

func methodType(method *protogen.Method) string {
	comments := strings.Split(string(method.Comments.Leading), ";")
	for _, comment := range comments {
		t := strings.TrimSpace(comment)
		if t == MethodSend || t == MethodCall || t == MethodRawCall {
			return t
		}
	}
	return MethodCall
}

func methodTypeRaw(t string) bool {
	return t == MethodSend || t == MethodRawCall
}

func genServiceInterface(g *protogen.GeneratedFile, srv *protogen.Service) {
	g.P("// ", srv.GoName, "Interface is the server API for ", srv.GoName, " service.")
	g.P("type ", srv.GoName, "Interface interface {")

	for _, method := range srv.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			continue
		}

		if methodTypeRaw(methodType(method)) {
			g.P(method.Comments.Leading, "On", method.GoName, "(*", gactorPackage.Ident("DispatchMessage"), ", *", genMessageName(method.Input), ") error")
		} else {
			g.P(method.Comments.Leading, "On", method.GoName, "(*", gactorPackage.Ident("DispatchMessage"), ", *", genMessageName(method.Input), ") (*", genMessageName(method.Output), ", error)")
		}
	}
	g.P("}")
}

func genMessageName(msg *protogen.Message) protogen.GoIdent {
	switch msg.Location.SourceFile {
	default:
		return msg.GoIdent
	}
}

func genServer(g *protogen.GeneratedFile, srv *protogen.Service) {
	g.P("type ", srv.GoName, "Proto struct {")
	g.P("s ", srv.GoName, "Interface")
	g.P("}")

	g.P("func (s *", srv.GoName, "Proto) register(p ", gactorPackage.Ident("Proto"), ") {")
	for _, method := range srv.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			continue
		}

		g.P("p.Register(")
		g.P("\"", srv.GoName, ".", method.GoName, "\",")
		g.P("func(ctx *", gactorPackage.Ident("DispatchMessage"), ", args ... interface{}) error {")

		if methodTypeRaw(methodType(method)) {
			g.P("err := s.s.On", method.GoName, "(ctx, args[0].(*", genMessageName(method.Input), "))")
			g.P("if err != nil {")
			g.P("ctx.System.Logger().Error(\"message process error\", ", zapPackage.Ident("Error"), "(err))")
			g.P("}")
			g.P("return err")
		} else {
			g.P("rsp, err := s.s.On", method.GoName, "(ctx, args[0].(*", genMessageName(method.Input), "))")
			g.P("")
			g.P("if err != nil {")
			g.P("ctx.Response(err, nil)")
			g.P("} else {")
			g.P("ctx.Response(nil, rsp)")
			g.P("}")
			g.P("return nil")
		}

		g.P("},")
		g.P("func() ", protoPackage.Ident("Message"), " { return new(", genMessageName(method.Input), ") },")
		g.P("func() ", protoPackage.Ident("Message"), " { return new(", genMessageName(method.Output), ") },")
		g.P(")")
		g.P("")
	}
	g.P("}")

}

func genClient(g *protogen.GeneratedFile, srv *protogen.Service) {
	g.P("type ", srv.GoName, "Client struct {")
	g.P("Proto ", gactorPackage.Ident("Proto"))
	g.P("}")

	for _, method := range srv.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			continue
		}

		if methodType(method) == MethodSend {
			g.P("func (client *", srv.GoName, "Client) ", method.GoName,
				"(system * ", gactorPackage.Ident("ActorSystem"),
				", actor ", gactorPackage.Ident("Actor"),
				", dest *", gactorPackage.Ident("ActorAddr"),
				", req *", genMessageName(method.Input),
				", options *", gactorPackage.Ident("CallOptions"),
				") error {",
			)
			g.P("err := actor.SendProto(system, dest, client.Proto.Id(), options, \"", srv.GoName, ".", method.GoName, "\", req)")
			g.P("")
			g.P("return err")
			g.P("}")
			g.P("")
		} else {
			g.P("func (client *", srv.GoName, "Client) ", method.GoName,
				"(ctx ", contextPackage.Ident("Context"),
				", system * ", gactorPackage.Ident("ActorSystem"),
				", actor ", gactorPackage.Ident("Actor"),
				", dest *", gactorPackage.Ident("ActorAddr"),
				", req *", genMessageName(method.Input),
				", options *", gactorPackage.Ident("CallOptions"),
				") (*", genMessageName(method.Output), ", error) {",
			)
			g.P("rsp, err := actor.CallProto(ctx, system, dest, client.Proto.Id(), options, \"", srv.GoName, ".", method.GoName, "\", req)")
			g.P("")
			g.P("if err != nil {")
			g.P("return nil, err")
			g.P("}")
			g.P("return rsp[0].(*", genMessageName(method.Output), "), nil")
			g.P("}")
			g.P("")
		}
	}
}

func genConstructor(g *protogen.GeneratedFile, srv *protogen.Service) {
	g.P("func Register", srv.GoName, "(s ", srv.GoName, "Interface, proto ", gactorPackage.Ident("Proto"), ") {")
	g.P("    reg := &", srv.GoName, "Proto{s: s}")
	g.P("    reg.register(proto)")
	g.P("}")

	g.P("func New", srv.GoName, "Client(proto ", gactorPackage.Ident("Proto"), ") *", srv.GoName, "Client {")
	g.P("    client := &", srv.GoName, "Client{Proto: proto}")
	g.P("    return client")
	g.P("}")
}

func main() {
	protogen.Options{}.Run(func(p *protogen.Plugin) error {
		for _, f := range p.Files {
			if f.Generate {
				if _, err := GenerateFile(p, f); err != nil {
					return err
				}
			}
		}

		return nil
	})
}
